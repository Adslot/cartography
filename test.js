// Generated by CoffeeScript 1.7.1
(function() {
  var CartographyError, assert, async, cartography, doMap, filters, from, isCartographyError, same,
    __slice = [].slice;

  assert = require('assert');

  cartography = require('./cartography');

  from = cartography.from, same = cartography.same, filters = cartography.filters, async = cartography.async, isCartographyError = cartography.isCartographyError, CartographyError = cartography.CartographyError;

  doMap = function(patient, arrayFilter) {
    return function(model, cb) {
      var ADSERVERS, CURRENCIES, dimension, id, isOneOf, optional, price, required, string, triggerNormalError;
      optional = filters.optional, required = filters.required, isOneOf = filters.isOneOf;
      triggerNormalError = function(v) {
        if (v !== 'triggerError') {
          return v;
        } else {
          throw new Error('ERROR');
        }
      };
      string = [required, filters.isString];
      id = price = [required, filters.isInteger];
      dimension = function(v) {
        return required(filters.isInteger(v));
      };
      CURRENCIES = ['AUD', 'USD', 'GBP', 'EUR', 'NZD'];
      ADSERVERS = ['adslot', 'dfp', 'openx', 'other'];
      return patient(model, {
        id: same(optional, id),
        publisherId: same(id),
        siteId: same(id),
        name: same(string),
        description: from('position', string),
        url: from('pageUrl', string),
        device: from('mediaDeviceType', isOneOf(['desktop', 'tablet', 'mobile'])),
        adFormats: from('adUnits', arrayFilter(required, triggerNormalError, function(au) {
          return "" + (dimension(au.width)) + "x" + (dimension(au.height));
        })),
        rate: {
          currencyCode: from('currency', isOneOf(CURRENCIES)),
          value: from('price', price)
        },
        adServer: async(function(model, cb) {
          var schema;
          schema = (function() {
            switch (model.adServer) {
              case 'dfp':
                return {
                  accountId: from('dfp.networkCode', string),
                  placementId: from('dfp.placementId', id)
                };
              case 'openx':
                return {
                  accountId: from('openx.accountId', string),
                  siteId: from('openx.siteId', id)
                };
              default:
                return {};
            }
          })();
          schema.type = from('adServer', isOneOf(ADSERVERS));
          return patient(model, schema, cb);
        }),
        minimumSpend: {
          value: from('minimumOrderPrice', price),
          currencyCode: from('currency', isOneOf(CURRENCIES))
        }
      }, cb);
    };
  };

  describe('cartography', function() {
    var patient, patientHelper, syncToAsync, version, versions, _fn, _ref;
    syncToAsync = function(syncFn) {
      return function() {
        var args, cb, e, result, _i;
        args = 2 <= arguments.length ? __slice.call(arguments, 0, _i = arguments.length - 1) : (_i = 0, []), cb = arguments[_i++];
        try {
          result = syncFn.apply(null, args);
        } catch (_error) {
          e = _error;
          return cb(e);
        }
        return cb(null, result);
      };
    };
    versions = {
      map: {
        patient: syncToAsync(cartography.map),
        patientHelper: syncToAsync(doMap(cartography.map, filters.array))
      },
      asyncMap: {
        patient: cartography.asyncMap,
        patientHelper: doMap(cartography.asyncMap, filters.asyncArray)
      }
    };
    _fn = function(patient, patientHelper) {
      return describe("" + version + "(), common tests", function() {
        it('should return null rather than an empty object', function(done) {
          return patient({}, {
            unused: from('nothing')
          }, function(err, result) {
            if (err) {
              return done(err);
            }
            assert.equal(result, null);
            return done();
          });
        });
        it('should work at least', function(done) {
          var model;
          model = {
            id: 123,
            publisherId: 456,
            siteId: 789,
            name: 'A test product',
            position: 'This is a product used for testing',
            pageUrl: 'www.theproductsite.com/theproductpage',
            mediaDeviceType: 'mobile',
            adUnits: [
              {
                width: 350,
                height: 250
              }, {
                width: 768,
                height: 98,
                aSpuriousField: 'randomStuff'
              }
            ],
            currency: 'AUD',
            price: 1000,
            minimumOrderPrice: 2000,
            adServer: 'dfp',
            dfp: {
              networkCode: 'abcdef',
              placementId: 987654321
            }
          };
          return patientHelper(model, function(err, result) {
            if (err) {
              return done(err);
            }
            assert.deepEqual(result, {
              id: 123,
              publisherId: 456,
              siteId: 789,
              name: 'A test product',
              description: 'This is a product used for testing',
              url: 'www.theproductsite.com/theproductpage',
              device: 'mobile',
              adFormats: ['350x250', '768x98'],
              rate: {
                currencyCode: 'AUD',
                value: 1000
              },
              adServer: {
                type: 'dfp',
                accountId: 'abcdef',
                placementId: 987654321
              },
              minimumSpend: {
                value: 2000,
                currencyCode: 'AUD'
              }
            });
            return done();
          });
        });
        it('should produce a descriptive map error', function(done) {
          var model;
          model = {
            id: 123,
            publisherId: 456,
            siteId: 789,
            name: 'A test product',
            position: 'This is a product used for testing',
            pageUrl: 'www.theproductsite.com/theproductpage',
            mediaDeviceType: 'mobile',
            adUnits: [
              {
                width: 350,
                height: 250
              }, {
                width: 768,
                height: 98.1,
                aSpuriousField: 'randomStuff'
              }
            ],
            currency: 'AUD',
            price: 1000,
            minimumOrderPrice: 2000,
            adServer: 'dfp',
            dfp: {
              networkCode: 'abcdef',
              placementId: 987654321
            }
          };
          return patientHelper(model, function(err, res) {
            assert(err instanceof CartographyError, 'not a CartographyError');
            assert(/adUnits\[1\]: must be an integer number/.test(err), "invalid message '" + err + "'");
            return done();
          });
        });
        it('should handle array errors', function(done) {
          var model;
          model = {
            id: 123,
            publisherId: 456,
            siteId: 789,
            name: 'A test product',
            position: 'This is a product used for testing',
            pageUrl: 'www.theproductsite.com/theproductpage',
            mediaDeviceType: 'mobile',
            adUnits: 'I am not an array',
            currency: 'AUD',
            price: 1000,
            minimumOrderPrice: 2000,
            adServer: 'dfp',
            dfp: {
              networkCode: 'abcdef',
              placementId: 987654321
            }
          };
          return patientHelper(model, function(err, res) {
            assert(err instanceof CartographyError, 'not a CartographyError');
            assert(/adUnits: must be an Array/.test(err), "invalid message '" + err + "'");
            return done();
          });
        });
        it('should handle optional attributes', function(done) {
          var model;
          model = {
            publisherId: 456,
            siteId: 789,
            name: 'A test product',
            position: 'This is a product used for testing',
            pageUrl: 'www.theproductsite.com/theproductpage',
            mediaDeviceType: 'mobile',
            adUnits: [
              {
                width: 350,
                height: 250
              }, {
                width: 768,
                height: 98,
                aSpuriousField: 'randomStuff'
              }
            ],
            currency: 'AUD',
            price: 1000,
            minimumOrderPrice: 2000,
            adServer: 'dfp',
            dfp: {
              networkCode: 'abcdef',
              placementId: 987654321
            }
          };
          return patientHelper(model, function(err, res) {
            if (err) {
              return done(err);
            }
            assert.deepEqual(res, {
              publisherId: 456,
              siteId: 789,
              name: 'A test product',
              description: 'This is a product used for testing',
              url: 'www.theproductsite.com/theproductpage',
              device: 'mobile',
              adFormats: ['350x250', '768x98'],
              rate: {
                currencyCode: 'AUD',
                value: 1000
              },
              adServer: {
                type: 'dfp',
                accountId: 'abcdef',
                placementId: 987654321
              },
              minimumSpend: {
                value: 2000,
                currencyCode: 'AUD'
              }
            });
            return done();
          });
        });
        it('should complain about non-optional attributes', function(done) {
          var model;
          model = {
            publisherId: 456,
            name: 'A test product',
            position: 'This is a product used for testing',
            pageUrl: 'www.theproductsite.com/theproductpage',
            mediaDeviceType: 'mobile',
            adUnits: [
              {
                width: 350,
                height: 250
              }, {
                width: 768,
                height: 98,
                aSpuriousField: 'randomStuff'
              }
            ],
            currency: 'AUD',
            price: 1000,
            minimumOrderPrice: 2000,
            adServer: 'dfp',
            dfp: {
              networkCode: 'abcdef',
              placementId: 987654321
            }
          };
          return patientHelper(model, function(err, res) {
            assert(err instanceof CartographyError, 'not a CartographyError');
            assert(/siteId: is required/.test(err), "invalid message '" + err + "'");
            return done();
          });
        });
        it('should let normal errors pass', function(done) {
          var model;
          model = {
            siteId: 3,
            publisherId: 456,
            name: 'A test product',
            position: 'This is a product used for testing',
            pageUrl: 'www.theproductsite.com/theproductpage',
            mediaDeviceType: 'mobile',
            adUnits: [
              {
                width: 350,
                height: 250
              }, 'triggerError', {
                width: 768,
                height: 98,
                aSpuriousField: 'randomStuff'
              }
            ],
            currency: 'AUD',
            price: 1000,
            minimumOrderPrice: 2000,
            adServer: 'dfp',
            dfp: {
              networkCode: 'abcdef',
              placementId: 987654321
            }
          };
          return patientHelper(model, function(err, res) {
            assert(!(err instanceof CartographyError), 'CartographyError instead of Error');
            assert(err instanceof Error, 'not an Error');
            assert(/ERROR/.test(err), "invalid message '" + err + "'");
            return done();
          });
        });
        return it('should recognize a missing object with nested attributes', function(done) {
          var model;
          model = {
            siteId: 3,
            publisherId: 456,
            name: 'A test product',
            position: 'This is a product used for testing',
            pageUrl: 'www.theproductsite.com/theproductpage',
            mediaDeviceType: 'mobile',
            adUnits: [],
            currency: 'AUD',
            price: 1000,
            minimumOrderPrice: 2000,
            adServer: 'dfp'
          };
          return patientHelper(model, function(err, res) {
            assert(err instanceof CartographyError, 'not an CartographyError');
            assert(/dfp.networkCode: is required/.test(err), "invalid message '" + err + "'");
            return done();
          });
        });
      });
    };
    for (version in versions) {
      _ref = versions[version], patient = _ref.patient, patientHelper = _ref.patientHelper;
      _fn(patient, patientHelper);
    }
    describe('isCartographyError()', function() {
      return it('should work at least', function() {
        assert(isCartographyError(new CartographyError));
        return assert(!isCartographyError(new Error));
      });
    });
    describe('same()', function() {
      return it('should produce an error if a filter is invalid', function() {
        return assert.throws((function() {
          return same({});
        }), /\[object Object\]/);
      });
    });
    describe('from()', function() {
      return it('should produce an error if a filter is invalid', function() {
        return assert.throws((function() {
          return from('whatever', {});
        }), /\[object Object\]/);
      });
    });
    return describe('default filters', function() {
      describe('array()', function() {
        it('should complain if the argument is not an array', function() {
          assert.throws((function() {
            return filters.array()('I am totally not an array');
          }), /must be an Array/);
          return assert.throws((function() {
            return filters.array()();
          }), /must be an Array/);
        });
        return it('should support chain breaking', function() {
          return assert.deepEqual(filters.array(filters.optional)([null]), [void 0]);
        });
      });
      describe('isOneOf()', function() {
        return it('should reject invalid values', function() {
          assert.throws((function() {
            return filters.isOneOf([])();
          }), /unrecognized value/);
          return assert.throws((function() {
            return filters.isOneOf([1, 2, 3])(4);
          }), /unrecognized value/);
        });
      });
      describe('isString()', function() {
        return it('should reject non-string values', function() {
          assert.throws((function() {
            return filters.isString([]);
          }), /must be a string/);
          assert.throws((function() {
            return filters.isString(null);
          }), /must be a string/);
          return assert.throws((function() {
            return filters.isString(123);
          }), /must be a string/);
        });
      });
      describe('isNumber()', function() {
        it('should pass a number', function() {
          return assert.equal(filters.isNumber(-34.5), -34.5);
        });
        return it('should reject a non-number', function() {
          return assert.throws((function() {
            return filters.isNumber('-34.5');
          }), CartographyError);
        });
      });
      describe('parseJSON()', function() {
        it('should parse correct JSON', function() {
          return assert.equal(filters.parseJSON('"a"'), 'a');
        });
        return it('should produce a Cartography error if JSON is invalid', function() {
          return assert.throws((function() {
            return filters.parseJSON('a');
          }), CartographyError);
        });
      });
      return describe('required()', function() {
        return it('should reject undefined values', function() {
          assert.equal(filters.required('whatever'), 'whatever');
          assert.throws((function() {
            return filters.required(void 0);
          }), /is required/);
          return assert.throws((function() {
            return filters.required(null);
          }), /is required/);
        });
      });
    });
  });

}).call(this);
